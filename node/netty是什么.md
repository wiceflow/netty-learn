## Nettey 是一个 RPC（远程调用框架）  



作为一个学 `Java` 的，如果没有研究过 `Netty`，那么你对 `Java` 语言的使用和理解仅仅停留在表面水平，会点 `SSH`，写几个 `MVC`，访问数据库和缓存，这些只是初等 `Java` 程序员干的事。如果你要进阶，想了解 `Java` 服务器的深层高阶知识，`Netty` 绝对是一个必须要过的门槛。  

有了 `Netty`，你可以实现自己的 `HTTP` 服务器，`FTP` 服务器，`UDP` 服务器，`RPC`  服务器，`WebSocket` 服务器，`Redis` 的 `Proxy` 服务器，`MySQL` 的`Proxy` 服务器等等。  

如果你想知道 `Nginx` 是怎么写出来的，如果你想知道 `Tomcat` 和 `Jetty` 是如何实现的，如果你也想实现一个简单的 `Redis` 服务器，那都应该好好理解一下 `Netty`，它们高性能的原理都是类似的。  

我们回顾一下传统的HTTP服务器的原理  

* 创建一个 `ServerSocket`，监听并绑定一个端口
* 一系列客户端来请求这个端口
* 服务器使用 `Accept`，获得一个来自客户端的 `Socket` 连接对象
* 启动一个新线程处理连接
  * 读 `Socket`，得到字节流
  * 解码协议，得到 `Http` 请求对象
  * 处理 `Http` 请求，得到一个结果，封装成一个 `HttpResponse` 对象
  * 编码协议，将结果序列化字节流
  * 写 `Socket`，将字节流发给客户端
* 继续循环步骤3



`HTTP` 服务器之所以称为 `HTTP` 服务器，是因为编码解码协议是 `HTTP` 协议，如果协议是 `Redis` 协议，那它就成了 `Redis` 服务器，如果协议是 `WebSocket`，那它就成了 `WebSocket` 服务器，等等。

使用 `Netty` 你就可以定制编解码协议，实现自己的特定协议的服务器。

上面我们说的是一个传统的多线程服务器，这个也是 `Apache` 处理请求的模式。在高并发环境下，线程数量可能会创建太多，操作系统的任务调度压力大，系统负载也会比较高。那怎么办呢？

于是 `NIO` 诞生了，`NIO` 并不是  `Java` 独有的概念，`NIO` 代表的一个词汇叫着 `IO` 多路复用。它是由操作系统提供的系统调用，早期这个操作系统调用的名字是`select`，但是性能低下，后来渐渐演化成了 `Linux` 下的 `epoll` 和Mac里的 `kqueue`。我们一般就说是 `epoll`，因为没有人拿苹果电脑作为服务器使用对外提供服务。而 `Netty` 就是基于 `Java NIO` 技术封装的一套框架。为什么要封装，因为原生的 `Java NIO` 使用起来没那么方便，而且还有臭名昭著的 `bug`，`Netty`把它封装之后，提供了一个易于操作的使用模式和接口，用户使用起来也就便捷多了。

那 `NIO` 究竟是什么东西呢？

`NIO` 的全称是 `NoneBlocking IO`，非阻塞 `IO`，区别与 `BIO`，`BIO` 的全称是 `Blocking IO`，阻塞 `IO`。那这个阻塞是什么意思呢？

* Accept 是阻塞的，只有新连接来了，Accept 才会返回，主线程才能继
* Read 是阻塞的，只有请求消息来了，Read 才能返回，子线程才能继续处理
* Write 是阻塞的，只有客户端把消息收了，Write 才能返回，子线程才能继续读取下一个请求



所以传统的多线程服务器是 `BlockingIO` 模式的，从头到尾所有的线程都是阻塞的。这些线程就干等在哪里，占用了操作系统的调度资源，什么事也不干，是浪费。

那么 `NIO` 是怎么做到非阻塞的呢。它用的是事件机制。它可以用一个线程把 `Accept`，读写操作，请求处理的逻辑全干了。如果什么事都没得做，它也不会死循环，它会将线程休眠起来，直到下一个事件来了再继续干活，这样的一个线程称之为 `NIO` 线程。  

```java
while true {
    events = takeEvents(fds)  // 获取事件，如果没有事件，线程就休眠
    for event in events {
        if event.isAcceptable {
            doAccept() // 新链接来了
        } elif event.isReadable {
            request = doRead() // 读消息
            if request.isComplete() {
                doProcess()
            }
        } elif event.isWriteable {
            doWrite()  // 写消息
        }
    }
}
```

`NIO` 的流程大致就是上面的伪代码描述的过程，跟实际真实的代码有较多差异，不过对于初学者，这样理解也是足够了。

`Netty` 是建立在 `NIO` 基础之上，`Netty` 在 `NIO` 之上又提供了更高层次的抽象。

在 `Netty` 里面，`Accept` 连接可以使用单独的线程池去处理，读写操作又是另外的线程池来处理。

`Accept` 连接和读写操作也可以使用同一个线程池来进行处理。而请求处理逻辑既可以使用单独的线程池进行处理，也可以跟放在读写线程一块处理。线程池中的每一个线程都是 `NIO` 线程。用户可以根据实际情况进行组装，构造出满足系统需求的并发模型。

`Netty` 提供了内置的常用编解码器，包括行编解码器［一行一个请求］，前缀长度编解码器［前N个字节定义请求的字节长度］，可重放解码器［记录半包消息的状态］，`HTTP` 编解码器，`WebSocket` 消息编解码器等等

`Netty` 提供了一些列生命周期回调接口，当一个完整的请求到达时，当一个连接关闭时，当一个连接建立时，用户都会收到回调事件，然后进行逻辑处理。

`Netty` 可以同时管理多个端口，可以使用 `NIO` 客户端模型，这些对于 `RPC服务` 是很有必要的。

`Netty` 除了可以处理 `TCP Socket` 之外，还可以处理 `UDP Socket`。

在消息读写过程中，需要大量使用 `ByteBuffer`，`Netty` 对 `ByteBuffer` 在性能和使用的便捷性上都进行了优化和抽象。

总之，`Netty` 是 `Java` 程序员进阶的必备神奇。如果你知其然，还想知其所以然，一定要好好研究下 `Netty`。如果你觉得 `Java` 枯燥无谓，`Netty` 则是重新开启你对 `Java` 兴趣大门的钥匙。